#!/bin/sh

# We must be root to change iptable rules
# Check if we're root, if not, fail
if [ "$(id -u)" != "0" ]; then
    echo "Error: This script must be run as root"
    exit 1
fi

LOCK_FILE="/tmp/searcher-network.lock"
STATE_FILE="/tmp/searcher-network.state"
TIMESTAMP_FILE="/tmp/searcher-network-last-stop.timestamp"

PODMAN="/usr/bin/podman"
CONTAINER_NAME="searcher-container"
IPTABLES="/usr/sbin/iptables"

# iptable chain names
SEARCHER_INPUT="SEARCHER_INPUT"
SEARCHER_OUTPUT="SEARCHER_OUTPUT"
SEARCHER_ESTABLISHED="SEARCHER_ESTABLISHED"
SEARCHER_MODE="SEARCHER_MODE" 
SEARCHER_BASE="SEARCHER_BASE"     

# Port configurations
SSH_DATA_PORT=10022
FB_STATE_DIFF_PORT=8547
TITAN_STATE_DIFF_PORT=8548

with_lock() {
    (
        flock -x 200
        "$@"
    ) 200>"$LOCK_FILE"
}

get_state() {
    if [ ! -f "$STATE_FILE" ]; then
        echo "maintenance"  # Default state
    else
        cat "$STATE_FILE"
    fi
}

set_state() {
    echo "$1" > "$STATE_FILE"
}

write_timestamp() {
    date +%s > "$TIMESTAMP_FILE"
}

check_delay() {
    if [ ! -f "$TIMESTAMP_FILE" ]; then
        echo "Error: No previous stop_production timestamp found"
        return 1
    fi
    
    last_stop=$(cat "$TIMESTAMP_FILE")
    current_time=$(date +%s)
    delay_seconds=10  # 2 minutes, CHANGED FOR DEBUGGING, REMOVE AFTER TESTING
    
    if [ $((current_time - last_stop)) -lt $delay_seconds ]; then
        remaining=$((delay_seconds - (current_time - last_stop)))
        echo "Error: Must wait $remaining more seconds before starting maintenance"
        return 1
    fi
    return 0
}

# New function to manage iptables rules
configure_mode_rules() {
    local mode=$1
    
    # First, flush mode-specific rules
    $IPTABLES -F $SEARCHER_MODE
    
    # Add new rules based on mode
    if [ "$mode" = "maintenance" ]; then
        # First block all state diff access
        $IPTABLES -A $SEARCHER_MODE -p tcp --dport $FB_STATE_DIFF_PORT -j DROP
        $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --sport $FB_STATE_DIFF_PORT -j DROP
        $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --dport $FB_STATE_DIFF_PORT -j DROP
        
        # Then enable SSH access
        $IPTABLES -A $SEARCHER_MODE -p tcp --dport $SSH_DATA_PORT -j ACCEPT
        $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --sport $SSH_DATA_PORT -m state --state ESTABLISHED,RELATED -j ACCEPT
        
    elif [ "$mode" = "production" ]; then
        # Block SSH access
        $IPTABLES -A $SEARCHER_MODE -p tcp --dport $SSH_DATA_PORT -j DROP
        $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --sport $SSH_DATA_PORT -j DROP

        # Enable state diff streams
        $IPTABLES -A $SEARCHER_MODE -p tcp --dport $FB_STATE_DIFF_PORT -j ACCEPT
        $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --sport $FB_STATE_DIFF_PORT -m state --state ESTABLISHED,RELATED -j ACCEPT
        $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --dport $FB_STATE_DIFF_PORT -m state --state ESTABLISHED,RELATED -j ACCEPT
        
    else  # stopped state
        # Drop SSH connections
        $IPTABLES -A $SEARCHER_MODE -p tcp --dport $SSH_DATA_PORT -j DROP
        $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --sport $SSH_DATA_PORT -j DROP

        # Drop state diff connections
        $IPTABLES -A $SEARCHER_MODE -p tcp --dport $FB_STATE_DIFF_PORT -j DROP
        $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --sport $FB_STATE_DIFF_PORT -j DROP
        $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --dport $FB_STATE_DIFF_PORT -j DROP
    fi
}

move_to_production() {
    if [ "$(get_state)" != "maintenance" ]; then
        echo "Error: Can only move to production from maintenance state"
        return 1
    fi
    echo "Moving to production mode..."
    if configure_mode_rules "production"; then
        set_state "production"
        echo "Successfully switched to production mode"
        return 0
    else
        echo "Failed to switch to production mode"
        return 1
    fi
}

disconnect_from_production() {
    write_timestamp
    if [ "$(get_state)" != "production" ]; then
        echo "Error: Can only disconnect from production state"
        return 1
    fi
    echo "Disconnecting from production mode..."
    if configure_mode_rules "stopped"; then
        set_state "stopped"
        echo "Successfully disconnected from production mode"
        return 0
    else
        echo "Failed to disconnect from production mode"
        return 1
    fi
}

connect_to_maintenance() {
    if [ "$(get_state)" != "stopped" ]; then
        echo "Error: Can only connect to maintenance from stopped state"
        return 1
    fi
    if ! check_delay; then
        return 1
    fi
    echo "Connecting to maintenance mode..."
    if configure_mode_rules "maintenance"; then
        set_state "maintenance"
        rm -f "$TIMESTAMP_FILE"  # Clear timestamp after successful use
        echo "Successfully connected to maintenance mode"
        return 0
    else
        echo "Failed to connect to maintenance mode"
        return 1
    fi
}

toggle() {
    current_state=$(get_state)
    case "$current_state" in
        "production")
            echo "Switching from production to stopped..."
            disconnect_from_production
            result=$?
            ;;
        "stopped")
            echo "Switching from stopped to maintenance..."
            connect_to_maintenance
            result=$?
            ;;
        "maintenance")
            echo "Switching from maintenance to production..."
            move_to_production
            result=$?
            ;;
        *)
            echo "Error: Unknown state: $current_state"
            return 1
            ;;
    esac
    if [ $result -eq 0 ]; then
        echo "Successfully switched state"
        return 0
    else
        echo "Failed to switch state"
        return 1
    fi
}

# Main execution
with_lock toggle
exit $?
#!/bin/sh
set -eux -o pipefail

### BEGIN INIT INFO
# Provides:          searcher-network
# Required-Start:    $network
# Required-Stop:     $network
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Searcher Network Configuration
# Description:       Sets up podman networks and iptables rules for searcher containers
### END INIT INFO

# Configuration variables
BUILDER_HOST=10.0.2.2
BUILDER_STATE_DIFF_PORT=8547
BUILDER_RPC_PORT=8645
BUILDER_CL_PORT=9000
BUILDER_SEARCHER_INPUT_PORT=27017
BUILDER_EL_PORT=30303
PODMAN="/usr/bin/podman"
IPTABLES="/usr/sbin/iptables"

# Network interface name
MAINTENANCE_INTERFACE="maintenance0"
ALWAYS_INTERFACE="always0"
PRODUCTION_INTERFACE="production0"

# Network CIDR ranges
MAINTENANCE_SUBNET="10.90.0.0/24"
ALWAYS_SUBNET="10.90.1.0/24"
PRODUCTION_SUBNET="10.90.2.0/24"

# Execute a command in the searcher's rootless netns context
in_netns() {
    su -s /bin/sh - searcher -c "podman unshare --rootless-netns sh -c \"$*\""
}

# Execute a command in the searcher's context
as_searcher() {
    su -s /bin/sh - searcher -c "$*"
}

# Network setup functions
setup_maintenance_network() {
    echo "Setting up maintenance network..."
    as_searcher "$PODMAN network create \
        --interface-name ${MAINTENANCE_INTERFACE} \
        --subnet ${MAINTENANCE_SUBNET} \
        --gateway 10.90.0.1 \
        maintenance" || return 1
}

setup_maintenance_firewall() {
    # Block state diff traffic for maintenance subnet
    in_netns "$IPTABLES -I FORWARD 1 -i ${MAINTENANCE_INTERFACE} -d ${BUILDER_HOST} -p tcp --dport ${BUILDER_STATE_DIFF_PORT} -j DROP"
    in_netns "$IPTABLES -I FORWARD 1 -o ${MAINTENANCE_INTERFACE} -s ${BUILDER_HOST} -p tcp --sport ${BUILDER_STATE_DIFF_PORT} -j DROP"
    return 0
}

setup_always_network() {
    echo "Setting up always network..."
    as_searcher "$PODMAN network create \
        --interface-name ${ALWAYS_INTERFACE} \
        --subnet ${ALWAYS_SUBNET} \
        --gateway 10.90.1.1 \
	--route 0.0.0.0/0,10.90.1.1,110 \
	--route ${BUILDER_HOST}/32,10.90.1.1,90 \
	--internal \
	--disable-dns \
        always" || return 1
}

setup_always_firewall() {
    # Default DROP for always subnet
    in_netns "$IPTABLES -I FORWARD 1 -i ${ALWAYS_INTERFACE} -j DROP"
    in_netns "$IPTABLES -I FORWARD 1 -o ${ALWAYS_INTERFACE} -j DROP"
    in_netns "$IPTABLES -I INPUT 1 -i ${ALWAYS_INTERFACE} -j DROP"
    in_netns "$IPTABLES -I OUTPUT 1 -o ${ALWAYS_INTERFACE} -j DROP"

    # Allow to continue established connections, is this necessary?
    in_netns "$IPTABLES -A NETAVARK_FORWARD -d ${ALWAYS_SUBNET} -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT"

    # Allow Builder traffic for specific ports
    for port in "${BUILDER_RPC_PORT}" "${BUILDER_CL_PORT}" "${BUILDER_SEARCHER_INPUT_PORT}" "${BUILDER_EL_PORT}"; do
        in_netns "$IPTABLES -I FORWARD 1 -i ${ALWAYS_INTERFACE} -d ${BUILDER_HOST} -p tcp --dport ${port} -j ACCEPT"
        in_netns "$IPTABLES -I FORWARD 1 -o ${ALWAYS_INTERFACE} -s ${BUILDER_HOST} -p tcp --sport ${port} -j ACCEPT"
    done

    # Then, switch to NAT table to add masquerading rules
    # First create a unique chain for the new network
    in_netns "$IPTABLES -t nat -N NETAVARK-ALWY0CHAIN"
    # Add the postrouting rule to direct traffic to the new chain
    in_netns "$IPTABLES -t nat -A POSTROUTING -s ${ALWAYS_SUBNET} -j NETAVARK-ALWY0CHAIN"
    # Add rules to the new NAT chain
    in_netns "$IPTABLES -t nat -A NETAVARK-ALWY0CHAIN -d ${ALWAYS_SUBNET} -j ACCEPT"
    in_netns "$IPTABLES -t nat -A NETAVARK-ALWY0CHAIN ! -d 224.0.0.0/4 -j MASQUERADE"
    
    # set forwarding to 1
    in_netns "echo 1 > /proc/sys/net/ipv4/conf/${ALWAYS_INTERFACE}/forwarding"

    return 0
}

setup_production_network() {
    echo "Setting up production network..."
    as_searcher "$PODMAN network create \
        --interface-name ${PRODUCTION_INTERFACE} \
        --subnet ${PRODUCTION_SUBNET} \
        --gateway 10.90.2.1 \
	--route 0.0.0.0/0,10.90.2.1,110 \
	--internal \
	--disable-dns \
        production" || return 1
}

setup_production_firewall() {
    # Default DROP for production subnet
    in_netns "$IPTABLES -I FORWARD 1 -i ${PRODUCTION_INTERFACE} -j DROP"
    in_netns "$IPTABLES -I FORWARD 1 -o ${PRODUCTION_INTERFACE} -j DROP"
    in_netns "$IPTABLES -I INPUT 1 -i ${PRODUCTION_INTERFACE} -j DROP"
    in_netns "$IPTABLES -I OUTPUT 1 -o ${PRODUCTION_INTERFACE} -j DROP"

    # Allow to continue established connections, is this necessary?
    in_netns "$IPTABLES -A NETAVARK_FORWARD -d ${PRODUCTION_SUBNET} -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT"

    # Allow Builder state diff traffic only
    in_netns "$IPTABLES -I FORWARD 1 -i ${PRODUCTION_INTERFACE} -d ${BUILDER_HOST} -p tcp --dport ${BUILDER_STATE_DIFF_PORT} -j ACCEPT"
    in_netns "$IPTABLES -I FORWARD 1 -o ${PRODUCTION_INTERFACE} -s ${BUILDER_HOST} -p tcp --sport ${BUILDER_STATE_DIFF_PORT} -j ACCEPT"
    
    # Allow Builder traffic for specific ports (replaces always network)
    for port in "${BUILDER_RPC_PORT}" "${BUILDER_CL_PORT}" "${BUILDER_SEARCHER_INPUT_PORT}" "${BUILDER_EL_PORT}"; do
        in_netns "$IPTABLES -I FORWARD 1 -i ${PRODUCTION_INTERFACE} -d ${BUILDER_HOST} -p tcp --dport ${port} -j ACCEPT"
        in_netns "$IPTABLES -I FORWARD 1 -o ${PRODUCTION_INTERFACE} -s ${BUILDER_HOST} -p tcp --sport ${port} -j ACCEPT"
    done

    # Then, switch to NAT table to add masquerading rules
    # First create a unique chain for the new network
    in_netns "$IPTABLES -t nat -N NETAVARK-PROD0CHAIN"
    # Add the postrouting rule to direct traffic to the new chain
    in_netns "$IPTABLES -t nat -A POSTROUTING -s ${PRODUCTION_SUBNET} -j NETAVARK-PROD0CHAIN"
    # Add rules to the new NAT chain
    in_netns "$IPTABLES -t nat -A NETAVARK-PROD0CHAIN -d ${PRODUCTION_SUBNET} -j ACCEPT"
    in_netns "$IPTABLES -t nat -A NETAVARK-PROD0CHAIN ! -d 224.0.0.0/4 -j MASQUERADE"

    return 0
}

start_infra_container() {
    # this is necessary, otherwise the rootless network namespace doesn't exist and the iptable rules will
    # be deleted/won't exist upon searcher pod creation
    as_searcher "$PODMAN run -d --name searcher-network-infra --restart always --network maintenance,always,production k8s.gcr.io/pause"
}

start_socat_forward() {
    in_netns "socat TCP-LISTEN:${BUILDER_STATE_DIFF_PORT},bind=10.90.2.1,fork,reuseaddr TCP:${BUILDER_HOST}:${BUILDER_STATE_DIFF_PORT}" &
}

# Network Cleanup Functions
cleanup_maintenance_firewall() {
    echo "Cleaning up maintenance network firewall rules..."
    # Remove state diff traffic blocks
    in_netns "$IPTABLES -D FORWARD -i ${MAINTENANCE_INTERFACE} -d ${BUILDER_HOST} -p tcp --dport ${BUILDER_STATE_DIFF_PORT} -j DROP"
    in_netns "$IPTABLES -D FORWARD -o ${MAINTENANCE_INTERFACE} -s ${BUILDER_HOST} -p tcp --sport ${BUILDER_STATE_DIFF_PORT} -j DROP"
    return 0
}

cleanup_always_firewall() {
    echo "Cleaning up always network firewall rules..."
    # Remove default DROP for always subnet
    in_netns "$IPTABLES -D FORWARD -i ${ALWAYS_INTERFACE} -j DROP"
    in_netns "$IPTABLES -D FORWARD -o ${ALWAYS_INTERFACE} -j DROP"
    in_netns "$IPTABLES -D INPUT -i ${ALWAYS_INTERFACE} -j DROP"
    in_netns "$IPTABLES -D OUTPUT -o ${ALWAYS_INTERFACE} -j DROP"

    # Remove established connections rule
    in_netns "$IPTABLES -D NETAVARK_FORWARD -d ${ALWAYS_SUBNET} -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT"

    # Remove Builder traffic rules for specific ports
    for port in "${BUILDER_RPC_PORT}" "${BUILDER_CL_PORT}" "${BUILDER_SEARCHER_INPUT_PORT}" "${BUILDER_EL_PORT}"; do
        in_netns "$IPTABLES -D FORWARD -i ${ALWAYS_INTERFACE} -d ${BUILDER_HOST} -p tcp --dport ${port} -j ACCEPT"
        in_netns "$IPTABLES -D FORWARD -o ${ALWAYS_INTERFACE} -s ${BUILDER_HOST} -p tcp --sport ${port} -j ACCEPT"
    done

    # Clean up NAT rules
    in_netns "$IPTABLES -t nat -D POSTROUTING -s ${ALWAYS_SUBNET} -j NETAVARK-ALWY0CHAIN"
    in_netns "$IPTABLES -t nat -F NETAVARK-ALWY0CHAIN"
    in_netns "$IPTABLES -t nat -X NETAVARK-ALWY0CHAIN"
    return 0
}

cleanup_production_firewall() {
    echo "Cleaning up production network firewall rules..."
    # Remove default DROP for production subnet
    in_netns "$IPTABLES -D FORWARD -i ${PRODUCTION_INTERFACE} -j DROP"
    in_netns "$IPTABLES -D FORWARD -o ${PRODUCTION_INTERFACE} -j DROP"
    in_netns "$IPTABLES -D INPUT -i ${PRODUCTION_INTERFACE} -j DROP"
    in_netns "$IPTABLES -D OUTPUT -o ${PRODUCTION_INTERFACE} -j DROP"

    # Remove established connections rule
    in_netns "$IPTABLES -D NETAVARK_FORWARD -d ${PRODUCTION_SUBNET} -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT"

    # Remove Builder state diff traffic rules
    in_netns "$IPTABLES -D FORWARD -i ${PRODUCTION_INTERFACE} -d ${BUILDER_HOST} -p tcp --dport ${BUILDER_STATE_DIFF_PORT} -j ACCEPT"
    in_netns "$IPTABLES -D FORWARD -o ${PRODUCTION_INTERFACE} -s ${BUILDER_HOST} -p tcp --sport ${BUILDER_STATE_DIFF_PORT} -j ACCEPT"

    # Remove Builder traffic rules for specific ports (replaces always network)
    for port in "${BUILDER_RPC_PORT}" "${BUILDER_CL_PORT}" "${BUILDER_SEARCHER_INPUT_PORT}" "${BUILDER_EL_PORT}"; do
        in_netns "$IPTABLES -D FORWARD -i ${ALWAYS_INTERFACE} -d ${BUILDER_HOST} -p tcp --dport ${port} -j ACCEPT"
        in_netns "$IPTABLES -D FORWARD -o ${ALWAYS_INTERFACE} -s ${BUILDER_HOST} -p tcp --sport ${port} -j ACCEPT"
    done

    # Clean up NAT rules
    in_netns "$IPTABLES -t nat -D POSTROUTING -s ${PRODUCTION_SUBNET} -j NETAVARK-PROD0CHAIN"
    in_netns "$IPTABLES -t nat -F NETAVARK-PROD0CHAIN"
    in_netns "$IPTABLES -t nat -X NETAVARK-PROD0CHAIN"
    return 0
}

case "$1" in
    start)
        echo "Setting up searcher networks..."
        if setup_maintenance_network && \
           setup_always_network && \
           setup_production_network && \
           start_infra_container && \
	   start_socat_forward && \
           setup_maintenance_firewall && \
           setup_always_firewall && \
           setup_production_firewall; then
            echo "Searcher networks setup completed successfully"
            exit 0
        else
            echo "Failed to setup searcher networks"
            exit 1
        fi
        ;;
    setup_firewall)
        echo "Setting up custom firewall rules..."
        if setup_maintenance_firewall && \
           setup_always_firewall && \
           setup_production_firewall; then
            echo "Custom firewall rules setup completed successfully"
            exit 0
        else
            echo "Failed to setup custom firewall rules"
            exit 1
        fi
        ;;
    cleanup_firewall)
        echo "Cleaning up custom firewall rules..."
        if cleanup_maintenance_firewall && \
           cleanup_always_firewall && \
           cleanup_production_firewall; then
            echo "Custom firewall rules cleanup completed successfully"
            exit 0
        else
            echo "Failed to cleanup custom firewall rules"
            exit 1
        fi
        ;;
    *)
        echo "Usage: $0 {start|setup_firewall|cleanup_firewall}"
        exit 1
        ;;
esac

exit 0

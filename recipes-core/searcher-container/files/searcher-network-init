#!/bin/sh
### BEGIN INIT INFO
# Provides:          searcher-network
# Required-Start:    $network searcher-container
# Required-Stop:     $network
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Searcher Network Configuration
# Description:       Sets up iptables rules for searcher container
### END INIT INFO

# Configuration variables
PODMAN="/usr/bin/podman"
IPTABLES="/usr/sbin/iptables"
CONTAINER_NAME="searcher-container"

# Port configurations
SSH_CONTROL_PORT=22
SSH_DATA_PORT=10022
# FB_CL_P2P_PORT=9000
# FB_EL_P2P_PORT=30303
FB_STATE_DIFF_PORT=8547
# TITAN_STATE_DIFF_PORT=8548
# FB_BUILDER_RPC_PORT=8645
# TITAN_BUILDER_RPC_PORT=8646
# SEARCHER_INPUT_PORT_1=27017
# SEARCHER_INPUT_PORT_2=27018

# Chain names for better organization and cleanup
SEARCHER_INPUT="SEARCHER_INPUT"
SEARCHER_OUTPUT="SEARCHER_OUTPUT"
SEARCHER_ESTABLISHED="SEARCHER_ESTABLISHED"
SEARCHER_MODE="SEARCHER_MODE"      # Mode-specific rules chain
SEARCHER_BASE="SEARCHER_BASE"      # Permanent rules chain

# make sure the container and openssh server is ready before we start setting up the network
wait_for_container_ready() {
    echo "Waiting for searcher container to be ready..."
    max_attempts=20
    attempt=1
    
    # Initialize flags
    ssh_ipv4_ready=0
    ssh_ipv6_ready=0
    
    while [ $attempt -le $max_attempts ]; do
        echo "Attempt $attempt/$max_attempts: Checking container status..."
        status=$(su -s /bin/sh searcher -c "$PODMAN container inspect --format '{{.State.Status}}' $CONTAINER_NAME" 2>/dev/null)
        if [ "$status" != "running" ]; then
            echo "Container status is '$status', waiting for 'running'"
            sleep 10
            attempt=$((attempt + 1))
            continue
        fi
        echo "Container status is 'running'"

        # Get logs into a file with both stdout and stderr
        su -s /bin/sh searcher -c "$PODMAN logs $CONTAINER_NAME 2>&1" > /tmp/container.log
        
        # Set flags based on grep results
        if grep -q "Server listening on 0.0.0.0 port 22" /tmp/container.log; then
            ssh_ipv4_ready=1
        fi
        
        if grep -q "Server listening on :: port 22" /tmp/container.log; then
            ssh_ipv6_ready=1
        fi

        echo "Current initialization state:"
        echo "- IPv4 SSH server: $([[ $ssh_ipv4_ready -eq 1 ]] && echo "Ready" || echo "Waiting")"
        echo "- IPv6 SSH server: $([[ $ssh_ipv6_ready -eq 1 ]] && echo "Ready" || echo "Waiting")"

        # If all required messages have been seen, container is ready
        if [ $ssh_ipv4_ready -eq 1 ] && [ $ssh_ipv6_ready -eq 1 ]; then
            echo "Container initialization complete"
            rm -f /tmp/container.log
            return 0
        fi
        
        sleep 10
        attempt=$((attempt + 1))
    done

    echo "Container failed to become ready within timeout"
    rm -f /tmp/container.log
    return 1
}

setup_base_rules() {
    # Create custom chains
    for chain in $SEARCHER_MODE $SEARCHER_BASE $SEARCHER_INPUT $SEARCHER_OUTPUT $SEARCHER_ESTABLISHED; do
        $IPTABLES -N $chain 2>/dev/null || true
        $IPTABLES -F $chain
    done

    # Link custom chains
    # All incoming traffic is routed to the searcher input chain
    $IPTABLES -A INPUT -j $SEARCHER_INPUT
    # All outgoing traffic is routed to the searcher output chain
    $IPTABLES -A OUTPUT -j $SEARCHER_OUTPUT

    # Mode-specific rules are evaluated first
    $IPTABLES -A $SEARCHER_INPUT -j $SEARCHER_MODE
    $IPTABLES -A $SEARCHER_OUTPUT -j $SEARCHER_MODE

    # Permanent rules are evaluated second
    $IPTABLES -A $SEARCHER_INPUT -j $SEARCHER_BASE
    $IPTABLES -A $SEARCHER_OUTPUT -j $SEARCHER_BASE
    
    # Instead of allowing all established connections, we route them through our chain
    $IPTABLES -A INPUT -m state --state ESTABLISHED,RELATED -j $SEARCHER_ESTABLISHED
    $IPTABLES -A OUTPUT -m state --state ESTABLISHED,RELATED -j $SEARCHER_ESTABLISHED

    # Default policy: DROP
    $IPTABLES -P INPUT DROP
    $IPTABLES -P FORWARD DROP
    $IPTABLES -P OUTPUT DROP

    # Allow loopback?
    # $IPTABLES -A INPUT -i lo -j ACCEPT
    # $IPTABLES -A OUTPUT -o lo -j ACCEPT
}

setup_maintenance_rules() {
    # # Control Plane SSH (always enabled)
    # $IPTABLES -A $SEARCHER_INPUT -p tcp --dport $SSH_CONTROL_PORT -j ACCEPT
    # $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --sport $SSH_CONTROL_PORT -m state --state ESTABLISHED -j ACCEPT
    
    # Data Plane SSH (enabled in maintenance)
    $IPTABLES -A $SEARCHER_MODE -p tcp --dport $SSH_DATA_PORT -j ACCEPT
    $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --sport $SSH_DATA_PORT -m state --state ESTABLISHED -j ACCEPT

    # # Consensus Client P2P
    # $IPTABLES -A $SEARCHER_INPUT -p tcp --dport $FB_CL_P2P_PORT -j ACCEPT
    # $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --sport $FB_CL_P2P_PORT -m state --state ESTABLISHED -j ACCEPT
    # $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --dport $FB_CL_P2P_PORT -m state --state ESTABLISHED -j ACCEPT

    # # Execution Client P2P
    # $IPTABLES -A $SEARCHER_INPUT -p tcp --dport $FB_EL_P2P_PORT -j ACCEPT
    # $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --sport $FB_EL_P2P_PORT -m state --state ESTABLISHED -j ACCEPT
    # $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --dport $FB_EL_P2P_PORT -m state --state ESTABLISHED -j ACCEPT

    # Builder RPC outputs
    # FB Builder
    # $IPTABLES -A $SEARCHER_OUTPUT -p tcp --dport $FB_BUILDER_RPC_PORT -j ACCEPT
    # $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --sport $FB_BUILDER_RPC_PORT -m state --state ESTABLISHED -j ACCEPT

    # # Titan Builder
    # $IPTABLES -A $SEARCHER_OUTPUT -p tcp --dport $TITAN_BUILDER_RPC_PORT -j ACCEPT
    # $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --sport $TITAN_BUILDER_RPC_PORT -m state --state ESTABLISHED -j ACCEPT

    # Searcher Input Channels (UDP)
    # $IPTABLES -A $SEARCHER_INPUT -p udp --dport $SEARCHER_INPUT_PORT_1 -j ACCEPT
    # $IPTABLES -A $SEARCHER_INPUT -p udp --dport $SEARCHER_INPUT_PORT_2 -j ACCEPT
    # No ESTABLISHED rules needed for UDP one-way communication
    # ESTABLISHED outgoing rules may be dangerous

    # State Diff Streams (disabled in maintenance)
    # Unnecessary in init since default policy is DROP
    # FB Builder
    # $IPTABLES -A $SEARCHER_INPUT -p tcp --dport $FB_STATE_DIFF_PORT -j DROP
    # $IPTABLES -A $SEARCHER_OUTPUT -p tcp --dport $FB_STATE_DIFF_PORT -j DROP
    # $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --sport $FB_STATE_DIFF_PORT -j DROP
    # $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --dport $FB_STATE_DIFF_PORT -j DROP
    
    # # Titan Builder
    # $IPTABLES -A $SEARCHER_INPUT -p tcp --dport $TITAN_STATE_DIFF_PORT -j DROP
    # $IPTABLES -A $SEARCHER_OUTPUT -p tcp --dport $TITAN_STATE_DIFF_PORT -j DROP
    # $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --sport $TITAN_STATE_DIFF_PORT -j DROP
    # $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --dport $TITAN_STATE_DIFF_PORT -j DROP
}

setup_permanent_rules() {
    # Control Plane SSH (always enabled)
    $IPTABLES -A $SEARCHER_BASE -p tcp --dport $SSH_CONTROL_PORT -j ACCEPT
    $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --sport $SSH_CONTROL_PORT -m state --state ESTABLISHED -j ACCEPT

    # # Consensus Client P2P
    # $IPTABLES -A $SEARCHER_BASE -p tcp --dport $FB_CL_P2P_PORT -j ACCEPT
    # $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --sport $FB_CL_P2P_PORT -m state --state ESTABLISHED -j ACCEPT
    # $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --dport $FB_CL_P2P_PORT -m state --state ESTABLISHED -j ACCEPT

    # # Execution Client P2P
    # $IPTABLES -A $SEARCHER_BASE -p tcp --dport $FB_EL_P2P_PORT -j ACCEPT
    # $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --sport $FB_EL_P2P_PORT -m state --state ESTABLISHED -j ACCEPT
    # $IPTABLES -A $SEARCHER_ESTABLISHED -p tcp --dport $FB_EL_P2P_PORT -m state --state ESTABLISHED -j ACCEPT

    # # Searcher Input Channels (UDP)
    # $IPTABLES -A $SEARCHER_BASE -p udp --dport $SEARCHER_INPUT_PORT_1 -j ACCEPT
    # $IPTABLES -A $SEARCHER_BASE -p udp --dport $SEARCHER_INPUT_PORT_2 -j ACCEPT
}

cleanup_rules() {
    # Remove custom chains from main chains
    $IPTABLES -D INPUT -j $SEARCHER_INPUT 2>/dev/null || true
    $IPTABLES -D OUTPUT -j $SEARCHER_OUTPUT 2>/dev/null || true
    $IPTABLES -D INPUT -m state --state ESTABLISHED,RELATED -j $SEARCHER_ESTABLISHED 2>/dev/null || true
    $IPTABLES -D OUTPUT -m state --state ESTABLISHED,RELATED -j $SEARCHER_ESTABLISHED 2>/dev/null || true

    # Flush and delete custom chains
    for chain in $SEARCHER_MODE $SEARCHER_BASE $SEARCHER_INPUT $SEARCHER_OUTPUT $SEARCHER_ESTABLISHED; do
        $IPTABLES -F $chain 2>/dev/null || true
        $IPTABLES -X $chain 2>/dev/null || true
    done

    # Reset default policies
    $IPTABLES -P INPUT DROP
    $IPTABLES -P FORWARD DROP
    $IPTABLES -P OUTPUT DROP
}

case "$1" in
    start)
        if ! wait_for_container_ready; then
            echo "Container is not ready, cannot proceed with network setup"
            exit 1
        fi

        echo "Setting up searcher network rules..."
        if setup_base_rules && setup_maintenance_rules && setup_permanent_rules; then
            echo "Network setup completed successfully"
            exit 0
        else
            echo "Failed to setup network rules"
            exit 1
        fi
        ;;
    stop)
        echo "Cleaning up searcher network rules..."
        if cleanup_rules; then
            echo "Network rules cleanup completed successfully"
            exit 0
        else
            echo "Failed to cleanup network rules"
            exit 1
        fi
        ;;
    status)
        echo "Current iptables rules:"
        $IPTABLES -L -v -n
        echo "\nCustom chains:"
        $IPTABLES -L $SEARCHER_INPUT -v -n
        $IPTABLES -L $SEARCHER_OUTPUT -v -n
        $IPTABLES -L $SEARCHER_ESTABLISHED -v -n
        ;;
    *)
        echo "Usage: $0 {start|stop|status}"
        exit 1
        ;;
esac

exit 0